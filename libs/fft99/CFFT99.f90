!> @par Subroutine CFFT99
! PURPOSE      PERFORMS MULTIPLE FAST FOURIER TRANSFORMS.  THIS PACKAGE
!              WILL PERFORM A NUMBER OF SIMULTANEOUS COMPLEX PERIODIC
!              FOURIER TRANSFORMS OR CORRESPONDING INVERSE TRANSFORMS.
!              THAT IS, GIVEN A SET OF COMPLEX GRIDPOINT VECTORS, THE
!              PACKAGE RETURNS A SET OF COMPLEX FOURIER
!              COEFFICIENT VECTORS, OR VICE VERSA.  THE LENGTH OF THE
!              TRANSFORMS MUST BE A NUMBER GREATER THAN 1 THAT HAS
!              NO PRIME FACTORS OTHER THAN 2, 3, AND 5.
!
!              THE PACKAGE CFFT99 CONTAINS SEVERAL USER-LEVEL ROUTINES:
!
!            SUBROUTINE CFTFAX
!                AN INITIALIZATION ROUTINE THAT MUST BE CALLED ONCE
!                BEFORE A SEQUENCE OF CALLS TO CFFT99
!                (PROVIDED THAT N IS NOT CHANGED).
!
!            SUBROUTINE CFFT99
!                THE ACTUAL TRANSFORM ROUTINE ROUTINE, CABABLE OF
!                PERFORMING BOTH THE TRANSFORM AND ITS INVERSE.
!                HOWEVER, AS THE TRANSFORMS ARE NOT NORMALIZED,
!                THE APPLICATION OF A TRANSFORM FOLLOWED BY ITS
!                INVERSE WILL YIELD THE ORIGINAL VALUES MULTIPLIED
!                BY N.
!
!
! ACCESS       *FORTRAN,P=XLIB,SN=CFFT99
!
!
! USAGE        LET N BE OF THE FORM 2**P * 3**Q * 5**R, WHERE P .GE. 0,
!              Q .GE. 0, AND R .GE. 0.  THEN A TYPICAL SEQUENCE OF
!              CALLS TO TRANSFORM A GIVEN SET OF COMPLEX VECTORS OF
!              LENGTH N TO A SET OF (UNSCALED) COMPLEX FOURIER
!              COEFFICIENT VECTORS OF LENGTH N IS
!
!                   DIMENSION IFAX(13),TRIGS(2*N)
!                   COMPLEX A(...), WORK(...)
!
!                   CALL CFTFAX (N, IFAX, TRIGS)
!                   CALL CFFT99 (A,WORK,TRIGS,IFAX,INC,JUMP,N,LOT,ISIGN)
!
!              THE OUTPUT VECTORS OVERWRITE THE INPUT VECTORS, AND
!              THESE ARE STORED IN A.  WITH APPROPRIATE CHOICES FOR
!              THE OTHER ARGUMENTS, THESE VECTORS MAY BE CONSIDERED
!              EITHER THE ROWS OR THE COLUMNS OF THE ARRAY A.
!              SEE THE INDIVIDUAL WRITE-UPS FOR CFTFAX AND
!              CFFT99 BELOW, FOR A DETAILED DESCRIPTION OF THE
!              ARGUMENTS.
!
! HISTORY      THE PACKAGE WAS WRITTEN BY CLIVE TEMPERTON AT ECMWF IN
!              NOVEMBER, 1978.  IT WAS MODIFIED, DOCUMENTED, AND TESTED
!              FOR NCAR BY RUSS REW IN SEPTEMBER, 1980.  IT WAS
!              FURTHER MODIFIED FOR THE FULLY COMPLEX CASE BY DAVE
!              FULKER IN NOVEMBER, 1980.
!
!-----------------------------------------------------------------------
!
! SUBROUTINE CFTFAX (N,IFAX,TRIGS)
!
! PURPOSE      A SET-UP ROUTINE FOR CFFT99.  IT NEED ONLY BE
!              CALLED ONCE BEFORE A SEQUENCE OF CALLS TO CFFT99,
!              PROVIDED THAT N IS NOT CHANGED.
!
! ARGUMENT     IFAX(13),TRIGS(2*N)
! DIMENSIONS
!
! ARGUMENTS
!
! ON INPUT     N
!               AN EVEN NUMBER GREATER THAN 1 THAT HAS NO PRIME FACTOR
!               GREATER THAN 5.  N IS THE LENGTH OF THE TRANSFORMS (SEE
!               THE DOCUMENTATION FOR CFFT99 FOR THE DEFINITION OF
!               THE TRANSFORMS).
!
!              IFAX
!               AN INTEGER ARRAY.  THE NUMBER OF ELEMENTS ACTUALLY USED
!               WILL DEPEND ON THE FACTORIZATION OF N.  DIMENSIONING
!               IFAX FOR 13 SUFFICES FOR ALL N LESS THAN 1 MILLION.
!
!              TRIGS
!               A REAL ARRAY OF DIMENSION 2*N
!
! ON OUTPUT    IFAX
!               CONTAINS THE FACTORIZATION OF N.  IFAX(1) IS THE
!               NUMBER OF FACTORS, AND THE FACTORS THEMSELVES ARE STORED
!               IN IFAX(2),IFAX(3),...  IF N HAS ANY PRIME FACTORS
!               GREATER THAN 5, IFAX(1) IS SET TO -99.
!
!              TRIGS
!               AN ARRAY OF TRIGONOMETRIC FUNCTION VALUES SUBSEQUENTLY
!               USED BY THE CFT ROUTINES.
!
!-----------------------------------------------------------------------
!
! SUBROUTINE CFFT99 (A,WORK,TRIGS,IFAX,INC,JUMP,N,LOT,ISIGN)
!
! PURPOSE      PERFORM A NUMBER OF SIMULTANEOUS (UNNORMALIZED) COMPLEX
!              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE
!              TRANSFORMS.  GIVEN A SET OF COMPLEX GRIDPOINT
!              VECTORS, THE PACKAGE RETURNS A SET OF
!              COMPLEX FOURIER COEFFICIENT VECTORS, OR VICE
!              VERSA.  THE LENGTH OF THE TRANSFORMS MUST BE A
!              NUMBER HAVING NO PRIME FACTORS OTHER THAN
!              2, 3, AND 5.  THIS ROUTINE IS
!              OPTIMIZED FOR USE ON THE CRAY-1.
!
! ARGUMENT     COMPLEX A(N*INC+(LOT-1)*JUMP), WORK(N*LOT)
! DIMENSIONS   REAL TRIGS(2*N), INTEGER IFAX(13)
!
! ARGUMENTS
!
! ON INPUT     A
!               A COMPLEX ARRAY OF LENGTH N*INC+(LOT-1)*JUMP CONTAINING
!               THE INPUT GRIDPOINT OR COEFFICIENT VECTORS.  THIS ARRAY
!               OVERWRITTEN BY THE RESULTS.
!
!               N.B. ALTHOUGH THE ARRAY A IS USUALLY CONSIDERED TO BE OF
!               TYPE COMPLEX IN THE CALLING PROGRAM, IT IS TREATED AS
!               REAL WITHIN THE TRANSFORM PACKAGE.  THIS REQUIRES THAT
!               SUCH TYPE CONFLICTS ARE PERMITTED IN THE USER"S
!               ENVIRONMENT, AND THAT THE STORAGE OF COMPLEX NUMBERS
!               MATCHES THE ASSUMPTIONS OF THIS ROUTINE.  THIS ROUTINE
!               ASSUMES THAT THE REAL AND IMAGINARY PORTIONS OF A
!               COMPLEX NUMBER OCCUPY ADJACENT ELEMENTS OF MEMORY.  IF
!               THESE CONDITIONS ARE NOT MET, THE USER MUST TREAT THE
!               ARRAY A AS REAL (AND OF TWICE THE ABOVE LENGTH), AND
!               WRITE THE CALLING PROGRAM TO TREAT THE REAL AND
!               IMAGINARY PORTIONS EXPLICITLY.
!
!              WORK
!               A COMPLEX WORK ARRAY OF LENGTH N*LOT OR A REAL ARRAY
!               OF LENGTH 2*N*LOT.  SEE N.B. ABOVE.
!C
!C              TRIGS
!C               AN ARRAY SET UP BY CFTFAX, WHICH MUST BE CALLED FIRST.
!C
!C              IFAX
!C               AN ARRAY SET UP BY CFTFAX, WHICH MUST BE CALLED FIRST.
!C
!C
!C               N.B. IN THE FOLLOWING ARGUMENTS, INCREMENTS ARE MEASURED
!C               IN WORD PAIRS, BECAUSE EACH COMPLEX ELEMENT IS ASSUMED
!C               TO OCCUPY AN ADJACENT PAIR OF WORDS IN MEMORY.
!C
!C              INC
!C               THE INCREMENT (IN WORD PAIRS) BETWEEN SUCCESSIVE ELEMENT
!C               OF EACH (COMPLEX) GRIDPOINT OR COEFFICIENT VECTOR
!C               (E.G.  INC=1 FOR CONSECUTIVELY STORED DATA).
!C
!C              JUMP
!C               THE INCREMENT (IN WORD PAIRS) BETWEEN THE FIRST ELEMENTS
!C               OF SUCCESSIVE DATA OR COEFFICIENT VECTORS.  ON THE CRAY-
!               TRY TO ARRANGE DATA SO THAT JUMP IS NOT A MULTIPLE OF 8
!               (TO AVOID MEMORY BANK CONFLICTS).  FOR CLARIFICATION OF
!               INC AND JUMP, SEE THE EXAMPLES BELOW.
!
!              N
!               THE LENGTH OF EACH TRANSFORM (SEE DEFINITION OF
!               TRANSFORMS, BELOW).
!
!              LOT
!               THE NUMBER OF TRANSFORMS TO BE DONE SIMULTANEOUSLY.
!
!              ISIGN
!               = -1 FOR A TRANSFORM FROM GRIDPOINT VALUES TO FOURIER
!                    COEFFICIENTS.
!               = +1 FOR A TRANSFORM FROM FOURIER COEFFICIENTS TO
!                    GRIDPOINT VALUES.
!
! ON OUTPUT    A
!               IF ISIGN = -1, AND LOT GRIDPOINT VECTORS ARE SUPPLIED,
!               EACH CONTAINING THE COMPLEX SEQUENCE:
!
!               G(0),G(1), ... ,G(N-1)  (N COMPLEX VALUES)
!
!               THEN THE RESULT CONSISTS OF LOT COMPLEX VECTORS EACH
!               CONTAINING THE CORRESPONDING N COEFFICIENT VALUES:
!
!               C(0),C(1), ... ,C(N-1)  (N COMPLEX VALUES)
!
!               DEFINED BY:
!                 C(K) = SUM(J=0,...,N-1)( G(J)*EXP(-2*I*J*K*PI/N) )
!                 WHERE I = DSQRT(-1)
!
!
!               IF ISIGN = +1, AND LOT COEFFICIENT VECTORS ARE SUPPLIED,
!               EACH CONTAINING THE COMPLEX SEQUENCE:
!
!               C(0),C(1), ... ,C(N-1)  (N COMPLEX VALUES)
!
!              THEN THE RESULT CONSISTS OF LOT COMPLEX VECTORS EACH
!               CONTAINING THE CORRESPONDING N GRIDPOINT VALUES:
!
!               G(0),G(1), ... ,G(N-1)  (N COMPLEX VALUES)
!
!               DEFINED BY:
!                 G(J) = SUM(K=0,...,N-1)( G(K)*EXP(+2*I*J*K*PI/N) )
!                 WHERE I = DSQRT(-1)
!
!
!               A CALL WITH ISIGN=-1 FOLLOWED BY A CALL WITH ISIGN=+1
!               (OR VICE VERSA) RETURNS THE ORIGINAL DATA, MULTIPLIED
!               BY THE FACTOR N.
!
!
! EXAMPLE       GIVEN A 64 BY 9 GRID OF COMPLEX VALUES, STORED IN
!               A 66 BY 9 COMPLEX ARRAY, A, COMPUTE THE TWO DIMENSIONAL
!               FOURIER TRANSFORM OF THE GRID.  FROM TRANSFORM THEORY,
!               IT IS KNOWN THAT A TWO DIMENSIONAL TRANSFORM CAN BE
!               OBTAINED BY FIRST TRANSFORMING THE GRID ALONG ONE
!               DIRECTION, THEN TRANSFORMING THESE RESULTS ALONG THE
!               ORTHOGONAL DIRECTION.
!
!               COMPLEX A(66,9), WORK(64,9)
!               REAL TRIGS1(128), TRIGS2(18)
!               INTEGER IFAX1(13), IFAX2(13)
!
!               SET UP THE IFAX AND TRIGS ARRAYS FOR EACH DIRECTION:
!
!               CALL CFTFAX(64, IFAX1, TRIGS1)
!               CALL CFTFAX( 9, IFAX2, TRIGS2)
!
!               IN THIS CASE, THE COMPLEX VALUES OF THE GRID ARE
!               STORED IN MEMORY AS FOLLOWS (USING U AND V TO
!               DENOTE THE REAL AND IMAGINARY COMPONENTS, AND
!               ASSUMING CONVENTIONAL FORTRAN STORAGE):
!
!   U(1,1), V(1,1), U(2,1), V(2,1),  ...  U(64,1), V(64,1), 4 NULLS,
!
!   U(1,2), V(1,2), U(2,2), V(2,2),  ...  U(64,2), V(64,2), 4 NULLS,
!
!   .       .       .       .         .   .        .        .
!   .       .       .       .         .   .        .        .
!   .       .       .       .         .   .        .        .
!
!   U(1,9), V(1,9), U(2,9), V(2,9),  ...  U(64,9), V(64,9), 4 NULLS.
!
!               WE CHOOSE (ARBITRARILY) TO TRANSORM FIRST ALONG THE
!               DIRECTION OF THE FIRST SUBSCRIPT.  THUS WE DEFINE
!               THE LENGTH OF THE TRANSFORMS, N, TO BE 64, THE
!               NUMBER OF TRANSFORMS, LOT, TO BE 9, THE INCREMENT
!               BETWEEN ELEMENTS OF EACH TRANSFORM, INC, TO BE 1,
!               AND THE INCREMENT BETWEEN THE STARTING POINTS
!               FOR EACH TRANSFORM, JUMP, TO BE 66 (THE FIRST
!               DIMENSION OF A).
!
!               CALL CFFT99( A, WORK, TRIGS1, IFAX1, 1, 66, 64, 9, -1)
!
!                TO TRANSFORM ALONG THE DIRECTION OF THE SECOND SUBSCRIPT
!               THE ROLES OF THE INCREMENTS ARE REVERSED.  THUS WE DEFIN
!               THE LENGTH OF THE TRANSFORMS, N, TO BE 9, THE
!               NUMBER OF TRANSFORMS, LOT, TO BE 64, THE INCREMENT
!               BETWEEN ELEMENTS OF EACH TRANSFORM, INC, TO BE 66,
!               AND THE INCREMENT BETWEEN THE STARTING POINTS
!               FOR EACH TRANSFORM, JUMP, TO BE 1
!
!               CALL CFFT99( A, WORK, TRIGS2, IFAX2, 66, 1, 9, 64, -1)
!
!               THESE TWO SEQUENTIAL STEPS RESULTS IN THE TWO-DIMENSIONA
!               FOURIER COEFFICIENT ARRAY OVERWRITING THE INPUT
!               GRIDPOINT ARRAY, A.  THE SAME TWO STEPS APPLIED AGAIN
!               WITH ISIGN = +1 WOULD RESULT IN THE RECONSTRUCTION OF
!               THE GRIDPOINT ARRAY (MULTIPLIED BY A FACTOR OF 64*9).
!
!
!-----------------------------------------------------------------------
!     SUBROUTINE "CFFT99" - MULTIPLE FAST COMPLEX FOURIER TRANSFORM
!
!>@param A     IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA
!>             WORK IS AN AREA OF SIZE N*LOT
!>@param TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES
!>@param IFAX  IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N
!>@param INC   IS THE INCREMENT WITHIN EACH DATA 'VECTOR'
!>             (E.G. INC=1 FOR CONSECUTIVELY STORED DATA)
!>@param JUMP  IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR
!>@param N     IS THE LENGTH OF THE DATA VECTORS
!>@param LOT   IS THE NUMBER OF DATA VECTORS

!>@param ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT
!>             = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL
!
!
!     VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN
!     PARALLEL.
!
!
!     THE INNERMOST TEMPERTON ROUTINES HAVE NO FACILITY FOR THE
!     FORWARD (ISIGN = -1) TRANSFORM.  THEREFORE, THE INPUT MUST BE
!     REARRANGED AS FOLLOWS:
!
!     THE ORDER OF EACH INPUT VECTOR,
!
!     G(0), G(1), G(2), ... , G(N-2), G(N-1)
!
!     IS REVERSED (EXCLUDING G(0)) TO YIELD
!
!     G(0), G(N-1), G(N-2), ... , G(2), G(1).
!
!     WITHIN THE TRANSFORM, THE CORRESPONDING EXPONENTIAL MULTIPLIER
!     IS THEN PRECISELY THE CONJUGATE OF THAT FOR THE NORMAL
!     ORDERING.  THUS THE FORWARD (ISIGN = -1) TRANSFORM IS
!     ACCOMPLISHED
!
!     FOR NFAX ODD, THE INPUT MUST BE TRANSFERRED TO THE WORK ARRAY,
!     AND THE REARRANGEMENT CAN BE ONE DURING THE MOVE.
!
!
!------------------------------------------------------------------------
    MODULE WPRECISIONFFT
        INTEGER,PARAMETER  :: WP=8 !KIND(0.0D0) !WORKING PRECESION
    END MODULE WPRECISIONFFT
    
    
      SUBROUTINE CFFT99(A,WORK,TRIGS,IFAX,INC,JUMP,N,LOT,ISIGN)
      USE WPRECISIONFFT
      IMPLICIT NONE
!      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!      INCLUDE 'mpif.h'   

!      DIMENSION A(*),WORK(*),TRIGS(*),IFAX(13)
      REAL(WP),INTENT(INOUT)  :: A(*)
      REAL(WP),INTENT(INOUT)  :: WORK(*)
      REAL(WP),INTENT(IN)      :: TRIGS(*)
      INTEGER(4),INTENT(IN)  :: IFAX(13)
      INTEGER(4),INTENT(IN)  :: INC
      INTEGER(4),INTENT(IN)  :: JUMP
      INTEGER(4),INTENT(IN)  :: N
      INTEGER(4),INTENT(IN)  :: LOT
      INTEGER(4),INTENT(IN)  :: ISIGN
      
      INTEGER(4) :: NN, NH, NFAX
      INTEGER(4) :: IBASE, ILAST
      INTEGER(4) :: JBASE
      INTEGER(4) :: I1, I2
      INTEGER(4) :: I, J, K, L, M
      INTEGER(4) :: INK
      INTEGER(4) :: JUM, JNK,JST
      INTEGER(4) :: IGO
      INTEGER(4) :: LA
      REAL(WP) :: HREAL
      REAL(WP) :: HIMAG
      
!*****************************************************************
      NN = N+N
      INK=INC+INC
      JUM = JUMP+JUMP
      NFAX=IFAX(1)
      JNK = 2
      JST = 2
      IF (ISIGN.GE.0) GO TO 30

      JNK = -2
      JST = NN-2
      IF (MOD(NFAX,2).EQ.1) GOTO 40
!C
!C     FOR NFAX EVEN, THE REARRANGEMENT MUST BE APPLIED DIRECTLY TO
!C     THE INPUT ARRAY.  THIS CAN BE DONE BY SWAPPING ELEMENTS.
!C
      IBASE = 1
      ILAST = (N-1)*INK
      NH = N/2
      DO 20 L=1,LOT
         I1 = IBASE+INK
         I2 = IBASE+ILAST
!DIR$ IVDEP
         DO 10 M=1,NH
!           SWAP REAL AND IMAGINARY PORTIONS
            HREAL = A(I1)
            HIMAG = A(I1+1)
            A(I1) = A(I2)
            A(I1+1) = A(I2+1)
            A(I2) = HREAL
            A(I2+1) = HIMAG
            I1 = I1+INK
            I2 = I2-INK
   10   CONTINUE
        IBASE = IBASE+JUM
   20 CONTINUE
      GOTO 100
!
   30 CONTINUE
      IF (MOD(NFAX,2).EQ.0) GOTO 100
!
   40 CONTINUE
!
!     DURING THE TRANSFORM PROCESS, NFAX STEPS ARE TAKEN, AND THE
!     RESULTS ARE STORED ALTERNATELY IN WORK AND IN A.  IF NFAX IS
!     ODD, THE INPUT DATA ARE FIRST MOVED TO WORK SO THAT THE FINAL
!     RESULT (AFTER NFAX STEPS) IS STORED IN ARRAY A.
!
!>    @note split all real input A into alternative real+Im parts, stored in work. 
      IBASE=1
      JBASE=1
      DO 60 L=1,LOT
!        MOVE REAL AND IMAGINARY PORTIONS OF ELEMENT ZERO
         WORK(JBASE) = A(IBASE)
         WORK(JBASE+1) = A(IBASE+1)
         I=IBASE+INK
         J=JBASE+JST
!DIR$ IVDEP
         DO 50 M=2,N
!           MOVE REAL AND IMAGINARY PORTIONS OF OTHER ELEMENTS (POSSIBLY IN
!           REVERSE ORDER, DEPENDING ON JST AND JNK)
            WORK(J) = A(I)
            WORK(J+1) = A(I+1)
            I=I+INK
            J=J+JNK
   50    CONTINUE
         IBASE=IBASE+JUM
         JBASE=JBASE+NN
   60 CONTINUE
!
  100 CONTINUE
!
!     PERFORM THE TRANSFORM PASSES, ONE PASS FOR EACH FACTOR.  DURING
!     EACH PASS THE DATA ARE MOVED FROM A TO WORK OR FROM WORK TO A.
!
!     FOR NFAX EVEN, THE FIRST PASS MOVES FROM A TO WORK
      IGO = 110
!     FOR NFAX ODD, THE FIRST PASS MOVES FROM WORK TO A
      IF (MOD(NFAX,2).EQ.1) IGO = 120
      LA=1
      DO 140 K=1,NFAX
         IF (IGO.EQ.120) GO TO 120
  110    CONTINUE
         CALL VPASSM(A(1),A(2),WORK(1),WORK(2),TRIGS, &
               INK,2,JUM,NN,LOT,N,IFAX(K+1),LA)
         IGO=120
         GO TO 130
  120    CONTINUE
         CALL VPASSM(WORK(1),WORK(2),A(1),A(2),TRIGS, &
               2,INK,NN,JUM,LOT,N,IFAX(K+1),LA)
         IGO=110
  130   CONTINUE
         LA=LA*IFAX(K+1)
  140 CONTINUE
!
!     AT THIS POINT THE FINAL TRANSFORM RESULT IS STORED IN A.

      RETURN
      END
